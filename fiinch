#!/usr/bin/env python3

from subprocess import check_output
from sys import platform as _platform

import argparse
import coloredlogs
import logging
import logging.handlers
import mimetypes
import os
import re
import sys

IGNORE_REGEXES = frozenset([r".*/\.Trash/.*"])

EQUIVALENT_BIDIRECTIONAL = [
    frozenset(['application/x-sh', 'text/x-shellscript'])
]

def main(argv, syserr_handler):
    parser = argparse.ArgumentParser(description="The file integrity checker. "
                            "See https://github.com/andrewferrier/fiinch for more information.")

    parser.add_argument('-v', '--verbose', action='count', default=0,
                        help="Make the output more verbose. This affects both the output logged to "
                        "the console. Using this twice makes it doubly verbose.")

    parser.add_argument('filenames', metavar="filename", nargs='+', help='Filenames')

    args = parser.parse_args(argv[1:])

    if syserr_handler:
        if args.verbose > 1:
            syserr_handler.setLevel(logging.DEBUG)
        elif args.verbose == 1:
            syserr_handler.setLevel(logging.INFO)
        else:
            syserr_handler.setLevel(logging.WARNING)

    for filename in args.filenames:
        for root, dirs, files in os.walk(filename):
            for file_one in files:
                full_file_name = os.path.join(root, file_one)

                continue_with_file = True

                for IGNORE_REGEX_PATTERN in IGNORE_REGEXES:
                    if re.fullmatch(IGNORE_REGEX_PATTERN, full_file_name):
                        continue_with_file = False
                        break

                if continue_with_file:
                        check_file(full_file_name)

def find_equivalents(mimetype):
    for set in EQUIVALENT_BIDIRECTIONAL:
        if mimetype in set:
            return list(set - frozenset([mimetype]))

    return []

def check_file(filename):
    logger = logging.getLogger("fiinch")

    logger.debug("Checking file " + filename)
    assert(os.path.lexists(filename))
    if not os.path.exists(filename):
        logger.warning(filename + " is likely a broken symbolic link.")

    _, actual_extension = os.path.splitext(filename)

    if not actual_extension == "":
        detected_mime_type = str(check_output(["file", "--brief", "--mime-type", "--keep-going", filename]), 'utf-8').rstrip('\n')
        logger.debug("Detected mime type is " + detected_mime_type)

        if actual_extension in mimetypes.types_map:
            expected_mime_types = [mimetypes.types_map[actual_extension]]
            logger.debug("Expected MIME type can be one of " + str(expected_mime_types))
        else:
            expected_mime_types = []

        if actual_extension in mimetypes.common_types:
            common_mime_types = mimetypes.common_types[actual_extension]
            logger.debug("Other common ones " + str(common_mime_types))
        else:
            common_mime_types = []

        if type(expected_mime_types) is str:
            expected_mime_types = [ expected_mime_types ]
        if type(common_mime_types) is str:
            common_mime_types = [ common_mime_types ]

        assert(type(common_mime_types) is list)
        assert(type(expected_mime_types) is list)

        total_mime_types = expected_mime_types + common_mime_types

        equivalent_mime_types = []

        for mime_type in total_mime_types:
            equivalents = find_equivalents(mime_type)
            logger.debug("Other equivalents of " + mime_type + ": " + str(equivalents))
            equivalent_mime_types = equivalent_mime_types + equivalents

        assert(type(equivalent_mime_types) is list)

        total_mime_types += equivalent_mime_types

        if len(total_mime_types) > 0:
            if detected_mime_type not in total_mime_types:
                logger.warning("Expected content mismatch. File " + filename + " was expected to have a mime type from " + str(total_mime_types) + " (mime type detected as " + detected_mime_type + ')')
        else:
            logger.debug("No known MIME types for " + actual_extension)

if __name__ == "__main__":
    logger_setup = logging.getLogger("fiinch")
    logger_setup.propagate = False
    logger_setup.setLevel(logging.DEBUG)

    coloredlogs.install(level=logging.DEBUG)

    sysErrHandler = coloredlogs.ColoredStreamHandler(stream=sys.stderr, show_timestamps=False, show_hostname=False, show_name=False, show_severity=False)
    sysErrHandler.setLevel(logging.WARNING)
    logger_setup.addHandler(sysErrHandler)

    main(sys.argv, sysErrHandler)
